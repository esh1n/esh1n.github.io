---
title: "Паттерн стратегия"
excerpt: "Как правильно сделать поддержку различных *поведений*"
header:
  overlay_image: https://habrastorage.org/getpro/habr/post_images/a74/120/d5b/a74120d5b954738ab73942c594530a2b.jpg
  overlay_filter: 0.5
  caption: "Photo credit: [**Паттерны от HeadFirst**](https://www.litres.ru/elizabet-robson/head-first-patterny-proektirovaniya-39123671/)"
categories:
  - IT Base
tags:
  - patterns
  - strategy
last_modified_at: 2020-10-26T13:05:25-05:00
toc: true
---

## Why patterns? 
 
Каждый разработчик после того, как освоит базовые и даже продвинутые техники ООП языка, сталкивается с проблемой архитектурного оформления кода. Зачем архитектура ? Неизбежно с развитием приложения растёт и его сложность. Нужно делать реализацию новых фичей так, чтобы она была масштабируемой т.е чтобы новый код было легко расширять.

В этом нам и помогут паттерны.

![Nice Valdai](/assets/images/2020-10-26_pattern_strategy/patterns_intro_why.jpg "Why we need patterns?")

***

### Ядро всех паттернов

В основе почти всех паттернов лежит простая концепция:
>Изменение некоторой части системы должно быть независимо от других частей, не должно влиять на другие части системы

Эту концепция можно выразить иначе:
>Выделите переменные состявляющие, аспекты приложения,которые могут изменяться, и отделите, инкапсулируйте их, чтобы позднее их можно было изменять или расширять без воздействия на постоянные составляющие.

## Имитатор утиного пруда

Разберем следующий пример. Есть игра - утиный пруд, в котором плавают и крякают утки рахных видов.

3 - лаконично поддержать новое поведение "утки летают".

***

### Первая мысль
о  том как пожжержать подобное решение , будет что-то вродe

![Duck class Start](/assets/images/2020-10-26_pattern_strategy/duckClass1.png "Duck class 1")

Однако данная реализация чревата _пустыми_ методами, т.е непереопреденными. В итоге код будет избыточным.

Действительно,зачем наделять класс DecoyDuck() функциональностью, который он никогда не будет реализовывать.Деревянная уточка никгда не будет крякать.

### Вторая мысль

Будет такая. а что если отказаться  от одного общего класса в угоду нескольким интерфейсам и тогда наделить тот или иной **Утиный** класс соответсв. набором интерфейсов. Примерно так:

![ducks_interfaced"](/assets/images/2020-10-26_pattern_strategy/duckClass2.jpeg) 

Однако тут мы сталкиваемся со следующей проблемой - 
эти интфейсы,нужно реализовывать ***каждый*** раз. и Нельзя сохранить и переиспользовать реализацию интефейса,т.е сохранить `поведение`.

> Каждый раз,когда встречаешь набор различных поведений, которые реализуют некий контракт и разница между ними лишь в реализации этого контракта - знай, перед тобой **Паттерн Стратегия**

Собственно, `разные поведения - это разные стратегии`.

### Отделяем переменное от постоянного

Абстрактно, это будет выглядеть так:

![abstract_solution](/assets/images/2020-10-26_pattern_strategy/solution_1.jpeg)

## Проектирование переменного поведения

Требования у реализации такие:  

1. Инициализация `*Duck` с конкретным типом поведения `fly()`
2. Runtime изменение поведения полета или крякания утки.

***Принцип проектирования:***
> Программируйте на уровне интерфейсов, а не уровне реализации.

Таким образом , аспект поведения, т.е контракт поведения будет задаваться через `interface`, а конкретная реализация  - через `class`, но фишка в том,что это будет класс *отдельный* , не класс `Duck`. 

>Duck не нужно знать подробности реализации своих аспектов поведения. Поведение будет инкасулировано от Duck в отдельных реализациях контракта данного поведения.

![fly_behaviour](/assets/images/2020-10-26_pattern_strategy/fly_behaviour.jpeg)

### Интеграция поведения с классом Duck

Класс Duck теперь ***делегирует*** свои аспекты поведения(*вместо простого использования методов,определенных в классе Duck или его субклассах*)

1. Сначала в класс Duck включаются две переменные экземпляров flyBehaviour and quackBehaviour, обьявленные с типом интерфейса.
На стадии инициализации присваеваем конкретную реализацию поведения.

2. Делегирование поведения - крякания и полета - в класс утка в  *perform* методы: performQuack, performFly. т.е Именно в них будут вызываться методы делегированного поведения. Звучит пространно, поэтому приведем код.

```java
   public class Duck{
   
   QuackBehaviour quackBehaviour;
   		
   	public void performQuack(){
   		quackBehaviour.quack();
   	}
  }
```
### Приведем теперь полную реализацию на `kotlin`.

<script src="https://gist.github.com/esh1n/96ad72208b6c19e8aca21d3b90b18b48.js"></script>

 
   